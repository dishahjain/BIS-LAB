import random
import math

# Problem data (weights and values of supplies)
weights = [10, 20, 30, 40, 15, 25, 35]
values = [60, 100, 120, 240, 80, 150, 200]
capacity = 100  # Max weight capacity of the truck

n_items = len(weights)
n_nests = 15
max_iter = 15
pa = 0.25  # Probability of abandoning worse nests

def fitness(solution):
    total_weight = sum(w for w, s in zip(weights, solution) if s == 1)
    total_value = sum(v for v, s in zip(values, solution) if s == 1)
    if total_weight > capacity:
        return 0  # Penalize overweight solutions
    else:
        return total_value

def generate_nest():
    # Generate random binary solution
    return [random.randint(0, 1) for _ in range(n_items)]

def levy_flight(Lambda=1.5):
    # Generate a Levy flight step (scalar)
    sigma_u = (math.gamma(1 + Lambda) * math.sin(math.pi * Lambda / 2) /
              (math.gamma((1 + Lambda) / 2) * Lambda * 2 ** ((Lambda - 1) / 2))) ** (1 / Lambda)
    u = random.gauss(0, sigma_u)
    v = random.gauss(0, 1)
    step = u / (abs(v) ** (1 / Lambda))
    return step

def get_cuckoo(nest, best_nest):
    new_nest = []
    for xi, bi in zip(nest, best_nest):
        step = levy_flight()
        val = xi + step * (xi - bi)
        # Sigmoid function to squash into (0,1)
        s = 1 / (1 + math.exp(-val))
        new_val = 1 if s > 0.5 else 0
        new_nest.append(new_val)
    return new_nest

def cuckoo_search():
    nests = [generate_nest() for _ in range(n_nests)]
    fitness_values = [fitness(nest) for nest in nests]

    best_index = fitness_values.index(max(fitness_values))
    best_nest = nests[best_index][:]
    best_fitness = fitness_values[best_index]

    for generation in range(1, max_iter + 1):
        # Generate new solutions via Levy flights
        for i in range(n_nests):
            new_nest = get_cuckoo(nests[i], best_nest)
            new_fitness = fitness(new_nest)
            if new_fitness > fitness_values[i]:
                nests[i] = new_nest
                fitness_values[i] = new_fitness

        # Abandon some nests and create new ones
        for i in range(n_nests):
            if random.random() < pa:
                nests[i] = generate_nest()
                fitness_values[i] = fitness(nests[i])

        current_best_index = fitness_values.index(max(fitness_values))
        current_best_fitness = fitness_values[current_best_index]

        if current_best_fitness > best_fitness:
            best_fitness = current_best_fitness
            best_nest = nests[current_best_index][:]

        # Print best fitness for current generation
        print(f"Generation {generation}: Best Fitness = {best_fitness}")

    return best_nest, best_fitness

if __name__ == "__main__":
    best_solution, best_value = cuckoo_search()
    total_weight = sum(w for w, s in zip(weights, best_solution) if s == 1)
    print("\nFinal Best packing solution (1 = selected):", best_solution)
    print("Total value of supplies packed:", best_value)
    print("Total weight:", total_weight)


